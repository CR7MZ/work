#include<iostream>
#include<vector>
using namespace std;

//二货小易有一个W*H的网格盒子，网格的行编号为0~H - 1，网格的列编号为0~W - 1。
//每个格子至多可以放一块蛋糕，任意两块蛋糕的欧几里得距离不能等于2。
//对于两个格子坐标(x1, y1), (x2, y2)的欧几里得距离为 :
//((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) 的算术平方根
//小易想知道最多可以放多少块蛋糕在网格盒子里。

//解析：
//首先我们要知道左上角一定可以放，并且对于整数坐标来说，欧几里得距离只是在横向和纵向距离为2
//斜对角距离不可能为2，由此可以得出此图，同时我们发现每四行四列为一个周期

//11001100 先看横向的（0，0）和（0,1）不会是为2，只有在有蛋糕的地方向后隔两个位置欧几里得距离才会为2，
//11001100 纵向亦是如此
//00110011
//00110011

int main()

{
	vector<int> v[1000];
	for (int i = 0; i < 1000; i++)//将数组初始化为0
	{
		v[i].resize(1000, 0);
	}
	int W, H;//H为行，W为列
	cin >> W >> H;
	for (int i = 0; i < H; i++)//从每行看
	{
		if (i % 4 == 0 || i % 4 == 1)//当行的坐标与4的余数为0或者1
		{
			for (int j = 0; j < W; j++)
			{
				if (j % 4 == 0 || j % 4 == 1)//从列看，同样当列的坐标与4的余数为0或者1时，可以放蛋糕
					v[i][j] = 1;
			}
		}
		else//当行的坐标与4的余数为2或者3
		{
			for (int j = 0; j < W; j++)
			{
				if (j % 4 == 2 || j % 4 == 3)//从列看，同样当列的坐标与4的余数为2或者3时，可以放蛋糕
					v[i][j] = 1;
			}
		}
	}
	int count = 0;
	for (int i = 0; i < H; i++)
	{
		for (int j = 0; j < W; j++)
		{
			if (v[i][j] == 1)
				count++;
		}
	}
	cout << count;
	return 0;
}